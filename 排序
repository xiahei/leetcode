#-*-coding:utf-8-*-

#quicksort
'''
array = [2,2,1,3]
[1,2,2,3]
array = [6, 8, 1, 4, 3, 9, 5, 4, 11, 2, 2, 15, 6]
[1, 2, 2, 3, 4, 4, 5, 6, 6, 8, 9, 11, 15]
array = [3,4,5,2]
[2,3,4,5]
'''
def partition(array,low,high):
    pivot = array[low]
    i,j = low,high
    while(low<high):#从右向左找到小于pivot的值,从左向右找到大于pivot的值,将两个值交换
        while(low<high) and (array[high] >= pivot):
            high = high - 1
        while(low<high) and (array[low] <= pivot):
            low = low + 1
        tmp = array[low]
        array[low] = array[high]
        array[high] = tmp
    #将pivot放入正确位置
    array[i] = array[low]
    array[low] = pivot
    return low


def quicksort(array,left,right):
    if left < right:
        pivot = partition(array,left,right)
        quicksort(array,left,pivot-1)
        quicksort(array,pivot+1,right)
    return array

if __name__ == "__main__":
    #array = [2,2,1,3]
    #array = [6, 8, 1, 4, 3, 9, 5, 4, 11, 2, 2, 15, 6]
    array = [3,4,5,2]
    newarray = quicksort(array,0,len(array)-1)
    print newarray

#堆排序（大顶堆、小顶堆）
#以大顶堆为例，堆排序共分为两个过程:1、将无序数组建成一个堆 2、将最大的数输出与数组最后一个数交换位置并输出，同时对新堆重新排序
#建堆存在两种方法：1、从左至右遍历数组，对每个元素做上浮操作 2、从右至左遍历数组，对每个元素做下沉操作
